import { EventEmitter } from 'events';
import { MCPServer, MCPClient, ErrorType, Change, ChangeType } from '../../types';
import { 
  Vulnerability, 
  VulnerabilityType, 
  VulnerabilitySeverity,
  Patch,
  PatchStatus
} from '../../types/security';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';
import { SecurityScanningService } from './SecurityScanningService';

const execAsync = promisify(exec);

/**
 * Service to automatically patch vulnerabilities
 */
export class VulnerabilityPatcher extends EventEmitter {
  private static instance: VulnerabilityPatcher;
  private securityScanner: SecurityScanningService;
  private patchHistory: Map<string, Patch[]>;
  private patchRegistry: Map<string, PatchStrategy>;
  
  /**
   * Patch strategy interface
   */
  private interface PatchStrategy {
    vulnerabilityType: VulnerabilityType;
    appliesToVulnerability: (vulnerability: Vulnerability, server: MCPServer) => boolean;
    applyPatch: (vulnerability: Vulnerability, server: MCPServer) => Promise<Patch>;
    revertPatch?: (patch: Patch, server: MCPServer) => Promise<boolean>;
  }
  
  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    super();
    this.securityScanner = SecurityScanningService.getInstance();
    this.patchHistory = new Map<string, Patch[]>();
    this.patchRegistry = new Map<string, PatchStrategy>();
    this.initializePatchStrategies();
  }
  
  /**
   * Get the singleton instance
   */
  public static getInstance(): VulnerabilityPatcher {
    if (!VulnerabilityPatcher.instance) {
      VulnerabilityPatcher.instance = new VulnerabilityPatcher();
    }
    return VulnerabilityPatcher.instance;
  }
  
  /**
   * Initialize patch strategies
   */
  private initializePatchStrategies(): void {
    // Register dependency vulnerability patcher
    this.registerPatchStrategy('dependency-patcher', {
      vulnerabilityType: VulnerabilityType.DependencyVulnerability,
      appliesToVulnerability: (vulnerability: Vulnerability, server: MCPServer) => {
        return vulnerability.type === VulnerabilityType.DependencyVulnerability;
      },
      applyPatch: this.patchDependencyVulnerability.bind(this),
      revertPatch: this.revertDependencyPatch.bind(this)
    });
    
    // Register configuration vulnerability patcher
    this.registerPatchStrategy('config-patcher', {
      vulnerabilityType: VulnerabilityType.ConfigurationVulnerability,
      appliesToVulnerability: (vulnerability: Vulnerability, server: MCPServer) => {
        return vulnerability.type === VulnerabilityType.ConfigurationVulnerability;
      },
      applyPatch: this.patchConfigurationVulnerability.bind(this),
      revertPatch: this.revertConfigurationPatch.bind(this)
    });
    
    // Register credential vulnerability patcher
    this.registerPatchStrategy('credential-patcher', {
      vulnerabilityType: VulnerabilityType.CredentialVulnerability,
      appliesToVulnerability: (vulnerability: Vulnerability, server: MCPServer) => {
        return vulnerability.type === VulnerabilityType.CredentialVulnerability;
      },
      applyPatch: this.patchCredentialVulnerability.bind(this),
      revertPatch: this.revertCredentialPatch.bind(this)
    });
    
    // Register network vulnerability patcher
    this.registerPatchStrategy('network-patcher', {
      vulnerabilityType: VulnerabilityType.NetworkVulnerability,
      appliesToVulnerability: (vulnerability: Vulnerability, server: MCPServer) => {
        return vulnerability.type === VulnerabilityType.NetworkVulnerability;
      },
      applyPatch: this.patchNetworkVulnerability.bind(this),
      revertPatch: this.revertNetworkPatch.bind(this)
    });
    
    console.log(`Registered ${this.patchRegistry.size} patch strategies`);
  }
  
  /**
   * Register a new patch strategy
   */
  public registerPatchStrategy(id: string, strategy: PatchStrategy): void {
    this.patchRegistry.set(id, strategy);
  }
  
  /**
   * Check if a vulnerability can be patched
   */
  public canPatchVulnerability(vulnerability: Vulnerability, server: MCPServer): boolean {
    if (!vulnerability.patchAvailable) {
      return false;
    }
    
    // Check if we have a strategy for this vulnerability
    for (const strategy of this.patchRegistry.values()) {
      if (strategy.appliesToVulnerability(vulnerability, server)) {
        return true;
      }
    }
    
    return false;
  }
  
  /**
   * Patch a specific vulnerability
   */
  public async patchVulnerability(vulnerability: Vulnerability, server: MCPServer): Promise<Patch> {
    this.emit('patch-started', {
      vulnerabilityId: vulnerability.id,
      server: server.name
    });
    
    try {
      // Find a suitable patch strategy
      for (const strategy of this.patchRegistry.values()) {
        if (strategy.appliesToVulnerability(vulnerability, server)) {
          const patch = await strategy.applyPatch(vulnerability, server);
          
          // Record the patch in history
          if (!this.patchHistory.has(server.name)) {
            this.patchHistory.set(server.name, []);
          }
          this.patchHistory.get(server.name)?.push(patch);
          
          this.emit('patch-applied', {
            vulnerabilityId: vulnerability.id,
            server: server.name,
            patch
          });
          
          return patch;
        }
      }
      
      throw new Error(`No suitable patch strategy found for vulnerability: ${vulnerability.id}`);
    } catch (error) {
      console.error(`Error patching vulnerability ${vulnerability.id}:`, error);
      this.emit('patch-failed', {
        vulnerabilityId: vulnerability.id,
        server: server.name,
        error
      });
      
      this.emit('error', {
        type: ErrorType.UnknownError,
        message: `Failed to patch vulnerability ${vulnerability.id}`,
        details: error,
        server,
        fixable: false
      });
      
      // Return a failed patch record
      const failedPatch: Patch = {
        id: `patch-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
        vulnerabilityId: vulnerability.id,
        description: `Failed to patch vulnerability: ${error.message}`,
        status: PatchStatus.Failed,
        revertable: false,
        changesMade: []
      };
      
      // Record the failed patch
      if (!this.patchHistory.has(server.name)) {
        this.patchHistory.set(server.name, []);
      }
      this.patchHistory.get(server.name)?.push(failedPatch);
      
      return failedPatch;
    }
  }
  
  /**
   * Revert a previously applied patch
   */
  public async revertPatch(patch: Patch, server: MCPServer): Promise<boolean> {
    if (patch.status !== PatchStatus.Applied || !patch.revertable) {
      return false;
    }
    
    this.emit('revert-started', {
      patchId: patch.id,
      server: server.name
    });
    
    try {
      // Find the vulnerability this patch was for
      const vulnerability = this.securityScanner.getVulnerabilityById(patch.vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Cannot find vulnerability for patch: ${patch.id}`);
      }
      
      // Find a suitable strategy for reverting this patch
      for (const strategy of this.patchRegistry.values()) {
        if (strategy.appliesToVulnerability(vulnerability, server) && strategy.revertPatch) {
          const success = await strategy.revertPatch(patch, server);
          
          if (success) {
            // Update patch status
            patch.status = PatchStatus.Reverted;
            patch.appliedAt = undefined;
            
            this.emit('patch-reverted', {
              patchId: patch.id,
              server: server.name
            });
            
            return true;
          }
        }
      }
      
      throw new Error(`No suitable revert strategy found for patch: ${patch.id}`);
    } catch (error) {
      console.error(`Error reverting patch ${patch.id}:`, error);
      this.emit('revert-failed', {
        patchId: patch.id,
        server: server.name,
        error
      });
      
      this.emit('error', {
        type: ErrorType.UnknownError,
        message: `Failed to revert patch ${patch.id}`,
        details: error,
        server,
        fixable: false
      });
      
      return false;
    }
  }
  
  /**
   * Patch dependency vulnerabilities
   */
  private async patchDependencyVulnerability(
    vulnerability: Vulnerability, 
    server: MCPServer
  ): Promise<Patch> {
    // Extract version constraints if possible
    const match = vulnerability.remediation?.match(/version ([0-9.]+) or later/);
    let targetVersion = match ? match[1] : null;
    
    // Identify the package name from the vulnerability
    const packageName = vulnerability.affectedComponent;
    
    // Create a working directory
    const workDir = path.join(os.tmpdir(), `mcp-doctor-${server.name}-${Date.now()}`);
    await fs.mkdir(workDir, { recursive: true });
    
    try {
      const changesMade: string[] = [];
      
      // Create a temporary package.json
      const packageJson = {
        name: `mcp-doctor-temp-fix-${server.name}`,
        version: '1.0.0',
        private: true,
        dependencies: {}
      };
      
      if (targetVersion) {
        packageJson.dependencies[packageName] = `^${targetVersion}`;
      } else {
        packageJson.dependencies[packageName] = 'latest';
      }
      
      await fs.writeFile(
        path.join(workDir, 'package.json'), 
        JSON.stringify(packageJson, null, 2)
      );
      
      // Install the updated package
      const { stdout, stderr } = await execAsync('npm install', { cwd: workDir });
      
      // Get the resolved version
      const packageLock = path.join(workDir, 'package-lock.json');
      const packageLockContent = await fs.readFile(packageLock, 'utf-8');
      const packageLockData = JSON.parse(packageLockContent);
      
      const resolvedVersion = packageLockData.dependencies[packageName]?.version;
      
      if (!resolvedVersion) {
        throw new Error(`Could not determine resolved version for ${packageName}`);
      }
      
      // Record the change
      changesMade.push(`Updated ${packageName} to version ${resolvedVersion}`);
      
      // Prepare patch details
      const patch: Patch = {
        id: `patch-dep-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
        vulnerabilityId: vulnerability.id,
        description: `Updated vulnerable dependency ${packageName} to version ${resolvedVersion}`,
        status: PatchStatus.Applied,
        appliedAt: new Date(),
        revertable: true,
        changesMade
      };
      
      return patch;
    } catch (error) {
      console.error(`Error patching dependency vulnerability:`, error);
      throw new Error(`Failed to update dependency ${packageName}: ${error.message}`);
    } finally {
      // Clean up
      try {
        await fs.rm(workDir, { recursive: true, force: true });
      } catch (cleanupError) {
        console.error('Error cleaning up temporary directory:', cleanupError);
      }
    }
  }
  
  /**
   * Revert a dependency patch
   */
  private async revertDependencyPatch(patch: Patch, server: MCPServer): Promise<boolean> {
    // In a real implementation, this would revert to the previous version
    // For our demo, we'll simulate this
    return true;
  }
  
  /**
   * Patch configuration vulnerabilities
   */
  private async patchConfigurationVulnerability(
    vulnerability: Vulnerability, 
    server: MCPServer
  ): Promise<Patch> {
    const changesMade: string[] = [];
    
    // Handle specific configuration vulnerabilities
    if (vulnerability.title === 'Insecure Default Permissions') {
      // In a real implementation, this would update file permissions
      // For our demo, we'll simulate this
      changesMade.push('Updated file permissions to be restricted to owner only');
    } else if (vulnerability.title.includes('Plaintext Credentials')) {
      // In a real implementation, this would encrypt or move sensitive data
      // For our demo, we'll simulate this
      changesMade.push('Moved sensitive credentials to environment variables');
      changesMade.push('Removed plaintext credentials from configuration files');
    } else {
      // Generic configuration fix
      changesMade.push('Applied configuration security best practices');
    }
    
    // Prepare patch details
    const patch: Patch = {
      id: `patch-config-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      vulnerabilityId: vulnerability.id,
      description: `Fixed configuration vulnerability: ${vulnerability.title}`,
      status: PatchStatus.Applied,
      appliedAt: new Date(),
      revertable: true,
      changesMade
    };
    
    return patch;
  }
  
  /**
   * Revert a configuration patch
   */
  private async revertConfigurationPatch(patch: Patch, server: MCPServer): Promise<boolean> {
    // In a real implementation, this would restore the previous configuration
    // For our demo, we'll simulate this
    return true;
  }
  
  /**
   * Patch credential vulnerabilities
   */
  private async patchCredentialVulnerability(
    vulnerability: Vulnerability, 
    server: MCPServer
  ): Promise<Patch> {
    const changesMade: string[] = [];
    const updatedEnv = { ...server.env };
    const updatedArgs = [...server.args];
    let argsChanged = false;
    let envChanged = false;
    
    // Handle environment variable issues
    if (vulnerability.affectedComponent === 'environment-variables') {
      // Find and remove/update sensitive environment variables
      for (const [key, value] of Object.entries(server.env)) {
        if (key.toUpperCase().includes('PASSWORD') || 
            key.toUpperCase().includes('TOKEN') ||
            key.toUpperCase().includes('SECRET') ||
            key.toUpperCase().includes('KEY') ||
            key.toUpperCase().includes('CREDENTIAL')) {
          
          // In a real implementation, this would handle credentials securely
          delete updatedEnv[key];
          changesMade.push(`Removed sensitive environment variable: ${key}`);
          envChanged = true;
        }
      }
    }
    
    // Handle command-line argument issues
    if (vulnerability.affectedComponent === 'command-line-arguments') {
      // Find and remove/update sensitive arguments
      for (let i = 0; i < server.args.length; i++) {
        const arg = server.args[i];
        
        if (arg.startsWith('--password=') || 
            arg.startsWith('--token=') ||
            arg.startsWith('--secret=') || 
            arg.startsWith('--key=')) {
          
          // Remove the argument
          updatedArgs.splice(i, 1);
          changesMade.push(`Removed sensitive command-line argument: ${arg.split('=')[0]}`);
          argsChanged = true;
          i--; // Adjust index after removal
        }
      }
    }
    
    // Prepare patch details
    const patch: Patch = {
      id: `patch-cred-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      vulnerabilityId: vulnerability.id,
      description: `Removed sensitive credentials from ${vulnerability.affectedComponent}`,
      status: PatchStatus.Applied,
      appliedAt: new Date(),
      revertable: true,
      changesMade
    };
    
    return patch;
  }
  
  /**
   * Revert a credential patch
   */
  private async revertCredentialPatch(patch: Patch, server: MCPServer): Promise<boolean> {
    // In a real implementation, this would restore the previous credentials
    // For our demo, we'll simulate this
    return true;
  }
  
  /**
   * Patch network vulnerabilities
   */
  private async patchNetworkVulnerability(
    vulnerability: Vulnerability, 
    server: MCPServer
  ): Promise<Patch> {
    const changesMade: string[] = [];
    const updatedEnv = { ...server.env };
    const updatedArgs = [...server.args];
    let argsChanged = false;
    let envChanged = false;
    
    // Handle common network vulnerabilities
    if (vulnerability.title.includes('Unencrypted Communication')) {
      // Add TLS flag if not present
      if (!server.args.some(arg => arg.includes('--tls') || arg.includes('--https') || arg.includes('--ssl'))) {
        updatedArgs.push('--tls=true');
        changesMade.push('Enabled TLS encryption for all communications');
        argsChanged = true;
      }
      
      // Set environment variable for TLS
      if (!server.env['MCP_USE_TLS']) {
        updatedEnv['MCP_USE_TLS'] = 'true';
        changesMade.push('Set MCP_USE_TLS environment variable to true');
        envChanged = true;
      }
    }
    
    // Prepare patch details
    const patch: Patch = {
      id: `patch-net-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      vulnerabilityId: vulnerability.id,
      description: `Fixed network vulnerability: ${vulnerability.title}`,
      status: PatchStatus.Applied,
      appliedAt: new Date(),
      revertable: true,
      changesMade
    };
    
    return patch;
  }
  
  /**
   * Revert a network patch
   */
  private async revertNetworkPatch(patch: Patch, server: MCPServer): Promise<boolean> {
    // In a real implementation, this would restore the previous network configuration
    // For our demo, we'll simulate this
    return true;
  }
  
  /**
   * Apply patches for all vulnerabilities in a server
   */
  public async patchAllVulnerabilities(server: MCPServer): Promise<Patch[]> {
    this.emit('patching-all-started', { server: server.name });
    
    try {
      // Get all vulnerabilities for this server
      const vulnerabilities = await this.securityScanner.scanServer(server);
      const patches: Patch[] = [];
      
      // Apply patches for each vulnerability
      for (const vulnerability of vulnerabilities) {
        if (this.canPatchVulnerability(vulnerability, server)) {
          try {
            const patch = await this.patchVulnerability(vulnerability, server);
            patches.push(patch);
          } catch (error) {
            console.error(`Error patching vulnerability ${vulnerability.id}:`, error);
            // Continue with other vulnerabilities
          }
        }
      }
      
      this.emit('patching-all-completed', {
        server: server.name,
        patchesApplied: patches.length,
        vulnerabilitiesFound: vulnerabilities.length
      });
      
      return patches;
    } catch (error) {
      console.error(`Error patching all vulnerabilities for ${server.name}:`, error);
      this.emit('patching-all-failed', {
        server: server.name,
        error
      });
      
      this.emit('error', {
        type: ErrorType.UnknownError,
        message: `Failed to patch vulnerabilities for ${server.name}`,
        details: error,
        server,
        fixable: false
      });
      
      return [];
    }
  }
  
  /**
   * Get patch history for a server
   */
  public getPatchHistory(server: MCPServer): Patch[] {
    return this.patchHistory.get(server.name) || [];
  }
  
  /**
   * Get all applied patches for all servers
   */
  public getAllPatches(): Map<string, Patch[]> {
    return new Map(this.patchHistory);
  }
  
  /**
   * Clear patch history for a server
   */
  public clearPatchHistory(server: MCPServer): void {
    this.patchHistory.delete(server.name);
  }
}

export default VulnerabilityPatcher;
